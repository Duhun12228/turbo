#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import rospy
import cv2 as cv
import numpy as np
from cv_bridge import CvBridge
from sensor_msgs.msg import CompressedImage
from std_msgs.msg import String


class SignTemplateMatcher:
    def __init__(self):
        rospy.init_node('sign_template_matcher')

        # --- Parameter ---
        self.image_topic = rospy.get_param("~image_topic", "/usb_cam/image_rect_color/compressed")

        left_tpl_path = rospy.get_param("~left_template_path", "/mnt/data/left.jpg")
        right_tpl_path = rospy.get_param("~right_template_path", "/mnt/data/right.jpg")

        # ROI가 강제로 리사이즈될 크기
        self.norm_size = rospy.get_param("~norm_size", 128)

        # 템플릿 매칭 threshold
        self.score_thresh = rospy.get_param("~score_thresh", 0.5)

        self.show_debug = rospy.get_param("~show_debug", True)

        # 색 기반 threshold (파란 원)
        self.lower_blue = np.array([100, 60, 40])
        self.upper_blue = np.array([130, 255, 255])

        # Load templates
        self.left_tpl_raw = cv.imread(left_tpl_path, cv.IMREAD_GRAYSCALE)
        self.right_tpl_raw = cv.imread(right_tpl_path, cv.IMREAD_GRAYSCALE)

        if self.left_tpl_raw is None or self.right_tpl_raw is None:
            rospy.logerr("템플릿 파일 불러오기 실패!")
            rospy.signal_shutdown("Template load failed")
            return

        # 템플릿도 동일한 크기로 강제 리사이즈
        self.left_tpl = cv.resize(self.left_tpl_raw, (self.norm_size, self.norm_size))
        self.right_tpl = cv.resize(self.right_tpl_raw, (self.norm_size, self.norm_size))

        self.bridge = CvBridge()

        self.image_sub = rospy.Subscriber(self.image_topic, CompressedImage,
                                          self.image_callback, queue_size=1)
        self.dir_pub = rospy.Publisher("/sign_direction", String, queue_size=1)

        rospy.loginfo("SignTemplateMatcher Node Started!")

    # ----------------------------------------------------

    def find_blue_sign_roi(self, frame):
        """
        파란 원형 표지판을 색 기반으로 검출 → ROI 반환
        """
        hsv = cv.cvtColor(frame, cv.COLOR_BGR2HSV)
        mask = cv.inRange(hsv, self.lower_blue, self.upper_blue)

        # 형태학적 연산
        kernel = np.ones((5, 5), np.uint8)
        mask = cv.morphologyEx(mask, cv.MORPH_OPEN, kernel, iterations=1)
        mask = cv.morphologyEx(mask, cv.MORPH_CLOSE, kernel, iterations=2)

        contours, _ = cv.findContours(mask, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE)
        if not contours:
            return None

        # 가장 큰 컨투어를 표지판으로 가정
        c = max(contours, key=cv.contourArea)
        x, y, w, h = cv.boundingRect(c)

        if w * h < 800:  # 너무 작은 노이즈 제거
            return None

        roi = frame[y:y+h, x:x+w]
        return roi

    # ----------------------------------------------------

    def template_match_direction(self, roi):
        """
        ROI를 강제로 고정 크기로 리사이즈 → 템플릿 매칭으로 LEFT/RIGHT 판별
        """
        roi_gray = cv.cvtColor(roi, cv.COLOR_BGR2GRAY)
        roi_resized = cv.resize(roi_gray, (self.norm_size, self.norm_size))

        res_left = cv.matchTemplate(roi_resized, self.left_tpl, cv.TM_CCOEFF_NORMED)
        res_right = cv.matchTemplate(roi_resized, self.right_tpl, cv.TM_CCOEFF_NORMED)

        left_score = res_left.max()
        right_score = res_right.max()

        best_score = max(left_score, right_score)

        if best_score < self.score_thresh:
            return "UNKNOWN", left_score, right_score

        direction = "RIGHT" if right_score > left_score else "LEFT"
        return direction, left_score, right_score

    # ----------------------------------------------------

    def image_callback(self, msg):
        try:
            frame = self.bridge.compressed_imgmsg_to_cv2(msg, desired_encoding="bgr8")
        except:
            return

        # 1) 파란 원 컨투어 기반 ROI 자동 찾기
        roi = self.find_blue_sign_roi(frame)

        if roi is None:
            direction = "UNKNOWN"
            left_score, right_score = 0, 0
        else:
            # 2) ROI 고정 리사이즈 → 템플릿 매칭
            direction, left_score, right_score = self.template_match_direction(roi)

        # Publish
        out = String()
        out.data = direction
        self.dir_pub.publish(out)

        rospy.loginfo_throttle(0.5,
            f"[SIGN] {direction} (L={left_score:.3f}, R={right_score:.3f})")

        # Debug
        if self.show_debug:
            debug = frame.copy()

            if roi is not None:
                h, w = roi.shape[:2]
                cv.imshow("ROI Sign", roi)

            cv.putText(debug, f"{direction}", (30, 60),
                       cv.FONT_HERSHEY_SIMPLEX, 1.5, (0, 0, 255), 3)
            cv.imshow("Sign Debug", debug)
            cv.waitKey(1)


# ----------------------------------------------------

if __name__ == "__main__":
    node = SignTemplateMatcher()
    try:
        rospy.spin()
    except rospy.ROSInterruptException:
        pass
    cv.destroyAllWindows()
