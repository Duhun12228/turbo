def sliding_window(self, img, n_windows=10, margin=12, minpix=5):
    y = img.shape[0]
    x = img.shape[1]

    histogram = np.sum(img[y//2:, :], axis=0)
    midpoint = int(histogram.shape[0] / 2)
    leftx_current = np.argmax(histogram[:midpoint])
    rightx_current = np.argmax(histogram[midpoint:]) + midpoint

    window_height = int(y / n_windows)
    nz = img.nonzero()

    left_lane_inds = []
    right_lane_inds = []

    lx, ly, rx, ry = [], [], [], []

    out_img = np.dstack((img, img, img)) * 255

    for window in range(n_windows):

        win_yl = y - (window + 1) * window_height
        win_yh = y - window * window_height

        win_xll = leftx_current - margin  # 녹색사각형 크기 : 가로 24, 세로 26
        win_xlh = leftx_current + margin
        win_xrl = rightx_current - margin
        win_xrh = rightx_current + margin

        cv.rectangle(out_img, (win_xll, win_yl), (win_xlh, win_yh), (0, 255, 0), 2)
        cv.rectangle(out_img, (win_xrl, win_yl), (win_xrh, win_yh), (0, 255, 0), 2)

        # 슬라이딩 윈도우 박스(녹색박스) 하나 안에 있는 흰색 픽셀의 x좌표를 모두 모은다.
        good_left_inds = ((nz[0] >= win_yl) & (nz[0] < win_yh) &
                          (nz[1] >= win_xll) & (nz[1] < win_xlh)).nonzero()[0]
        good_right_inds = ((nz[0] >= win_yl) & (nz[0] < win_yh) &
                           (nz[1] >= win_xrl) & (nz[1] < win_xrh)).nonzero()[0]

        left_lane_inds.append(good_left_inds)
        right_lane_inds.append(good_right_inds)

        # 구한 x좌표 리스트에서 흰색점이 5개 이상인 경우에 한해 x 좌표의 평균값을 구함. -> 이 값을 슬라이딩 윈도우의 중심점으로 사용
        if len(good_left_inds) > minpix:
            leftx_current = int(np.mean(nz[1][good_left_inds]))
        if len(good_right_inds) > minpix:
            rightx_current = int(np.mean(nz[1][good_right_inds]))

        # 여기까지는 기존대로 left, right 중심점 계속 추적
        lx.append(leftx_current)
        ly.append((win_yl + win_yh) / 2)

        rx.append(rightx_current)
        ry.append((win_yl + win_yh) / 2)

    left_lane_inds = np.concatenate(left_lane_inds)
    right_lane_inds = np.concatenate(right_lane_inds)

    # ===== 여기부터 변경 포인트 =====
    # 오른쪽 차선은 실제 검출값으로 직선 피팅
    rfit = np.polyfit(np.array(ry), np.array(rx), 1)
    a_r, b_r = rfit  # x = a_r * y + b_r

    # 프레임 가로의 절반만큼 왼쪽으로 평행 이동한 가상 왼쪽 차선
    # x_left(y) = a_r * y + (b_r - x/2)
    offset = x / 2.0
    lfit = np.array([a_r, b_r - offset])
    # ===== 변경 끝 =====

    # 왼쪽과 오른쪽 각각 파란색과 빨간색으로 색상 변경 (시각화 용도는 그대로 둠)
    out_img[nz[0][left_lane_inds], nz[1][left_lane_inds]] = [255, 0, 0]
    out_img[nz[0][right_lane_inds], nz[1][right_lane_inds]] = [0, 0, 255]

    cv.imshow("viewer", out_img)
    self.debug_publisher1.publish(self.cv_bridge.cv2_to_imgmsg(out_img))

    return lfit, rfit
