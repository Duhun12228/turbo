#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import cv2 as cv
import numpy as np
import math
import time

class LaneFollowVideo:
    def __init__(self):
        # --- íŒŒë¼ë¯¸í„° ---
        self.img_width  = 640
        self.img_height = 480

        # HSV (í™”ì´íŠ¸) ê¸°ë³¸ê°’
        self.white_lower = np.array([0, 0, 150], dtype=np.uint8)
        self.white_upper = np.array([180, 70, 255], dtype=np.uint8)

        # ì›ê·¼ ë³€í™˜ ì¢Œí‘œ (ì›ë˜ ì½”ë“œ ê·¸ëŒ€ë¡œ)
        self.src_points = np.float32([
            [0,   310],
            [640, 310],
            [0,   480],
            [640, 480]
        ])
        self.dst_points = np.float32([
            [0,   310],
            [640, 310],
            [225, 480],
            [415, 480]
        ])

        self.warp_mat = cv.getPerspectiveTransform(self.src_points, self.dst_points)
        self.inv_warp_mat = cv.getPerspectiveTransform(self.dst_points, self.src_points)

        self.gaussian_sigma = 1
        self.gear = 3  # 3ì´ default

        self.bgr = None
        self.warp_img = None
        self.white_img = None
        self.filtered_img = None

    def warpping(self, img):
        # ì…ë ¥ í”„ë ˆì„ í¬ê¸°ë¥¼ ê·¸ëŒ€ë¡œ ì‚¬ìš©í•´ì„œ warp
        h, w = img.shape[:2]
        warp_img = cv.warpPerspective(img, self.warp_mat, (w, h))
        return warp_img

    def Gaussian_filter(self, img):
        filtered_img = cv.GaussianBlur(img, (0, 0), self.gaussian_sigma)
        return filtered_img

    def white_color_filter_hsv(self, img):
        hsv = cv.cvtColor(img, cv.COLOR_BGR2HSV)
        white_hsv = cv.inRange(hsv, self.white_lower, self.white_upper)
        masked_img = cv.bitwise_and(img, img, mask=white_hsv)
        return masked_img

    # ë°˜ì‚¬ ë“± ì œê±° í›„ ëª…í™•í•˜ê²Œ
    def binary_filter(self, img):
        gray = cv.cvtColor(img, cv.COLOR_BGR2GRAY)
        _, binary = cv.threshold(gray, 100, 255, cv.THRESH_BINARY)
        return binary

    def roi_set(self, img):
        # ì›ë˜ ì½”ë“œ: img[310:480, 0:640]
        # ë†’ì´ê°€ 480ì´ ì•„ë‹ ìˆ˜ë„ ìˆì§€ë§Œ, ìŠ¬ë¼ì´ì‹±ì€ ìë™ìœ¼ë¡œ ì˜ë ¤ì„œ ì—ëŸ¬ëŠ” ì•ˆ ë‚¨.
        roi_img = img[310:480, 0:640]
        return roi_img

    def cal_steering(self, yaw, error, gear=3, k=0.0015):  # ê°ë„ rad, error px
        gear = self.gear

        if gear == 3:
            base_speed = 0.45
        elif gear == 2:
            base_speed = 0.35
        else:
            base_speed = 0.25

        steering = yaw + np.arctan2(k * error, base_speed)

        # ì¡°í–¥ê°ì´ í¬ë©´ ì†ë„ ì¤„ì´ê¸°
        steer_abs = abs(steering)

        angle_thresh = np.deg2rad(20.0)
        angle_max   = np.deg2rad(40.0)
        min_ratio   = 0.4

        if steer_abs <= angle_thresh:
            speed = base_speed
        else:
            ratio = 1.0 - (steer_abs - angle_thresh) / (angle_max - angle_thresh)
            ratio = np.clip(ratio, min_ratio, 1.0)
            speed = base_speed * ratio

        return steering, speed

    def sliding_window(self, img, n_windows=10, margin=12, minpix=5):
        y = img.shape[0]
        x = img.shape[1]

        histogram = np.sum(img[y // 2:, :], axis=0)
        midpoint = int(histogram.shape[0] / 2)
        leftx_current = np.argmax(histogram[:midpoint])
        rightx_current = np.argmax(histogram[midpoint:]) + midpoint

        window_height = int(y / n_windows)
        nz = img.nonzero()

        left_lane_inds = []
        right_lane_inds = []

        lx, ly, rx, ry = [], [], [], []

        out_img = np.dstack((img, img, img)) * 255

        for window in range(n_windows):

            win_yl = y - (window + 1) * window_height
            win_yh = y - window * window_height

            win_xll = leftx_current - margin
            win_xlh = leftx_current + margin
            win_xrl = rightx_current - margin
            win_xrh = rightx_current + margin

            cv.rectangle(out_img, (win_xll, win_yl), (win_xlh, win_yh), (0, 255, 0), 2)
            cv.rectangle(out_img, (win_xrl, win_yl), (win_xrh, win_yh), (0, 255, 0), 2)

            good_left_inds = ((nz[0] >= win_yl) & (nz[0] < win_yh) &
                              (nz[1] >= win_xll) & (nz[1] < win_xlh)).nonzero()[0]
            good_right_inds = ((nz[0] >= win_yl) & (nz[0] < win_yh) &
                               (nz[1] >= win_xrl) & (nz[1] < win_xrh)).nonzero()[0]

            left_lane_inds.append(good_left_inds)
            right_lane_inds.append(good_right_inds)

            if len(good_left_inds) > minpix:
                leftx_current = int(np.mean(nz[1][good_left_inds]))
            if len(good_right_inds) > minpix:
                rightx_current = int(np.mean(nz[1][good_right_inds]))

            lx.append(leftx_current)
            ly.append((win_yl + win_yh) / 2)

            rx.append(rightx_current)
            ry.append((win_yl + win_yh) / 2)

        left_lane_inds = np.concatenate(left_lane_inds)
        right_lane_inds = np.concatenate(right_lane_inds)

        # ìŠ¬ë¼ì´ë”© ìœˆë„ìš° ì¤‘ì‹¬ì ìœ¼ë¡œ 2ì°¨í•¨ìˆ˜ í”¼íŒ…
        lfit = np.polyfit(np.array(ly), np.array(lx), 1)
        rfit = np.polyfit(np.array(ry), np.array(rx), 1)

        out_img[nz[0][left_lane_inds], nz[1][left_lane_inds]] = [255, 0, 0]
        out_img[nz[0][right_lane_inds], nz[1][right_lane_inds]] = [0, 0, 255]

        cv.imshow("viewer", out_img)

        return lfit, rfit

    def cal_center_line(self, lfit, rfit):
        """
        lfit, rfit : np.polyfitìœ¼ë¡œ êµ¬í•œ ì™¼ìª½/ì˜¤ë¥¸ìª½ ì°¨ì„ ì˜ 1ì°¨ ë‹¤í•­ì‹ ê³„ìˆ˜
                     x = a*y + b í˜•íƒœ (len == 2)
        ë°˜í™˜ê°’:
            yaw   : ì¤‘ì•™ ì°¨ì„ ì˜ ì§„í–‰ ë°©í–¥ ê°ë„ (ë¼ë””ì•ˆ)
            error : ì°¨ëŸ‰(ì´ë¯¸ì§€ ì¤‘ì•™) ê¸°ì¤€, ì°¨ì„  ì¤‘ì•™ì˜ x ì˜¤í”„ì…‹(px)
        """

        # 1) ì™¼ìª½/ì˜¤ë¥¸ìª½ ì°¨ì„ ì˜ ê³„ìˆ˜ë¥¼ í‰ê· ë‚´ì„œ 'ì¤‘ì•™ì„ ' ê³„ìˆ˜ë¡œ ì‚¬ìš©
        cfit = (lfit + rfit) / 2.0  # [a, b]

        # 2) ì¤‘ì•™ì„ ì„ í‰ê°€í•  y ìœ„ì¹˜ ì„ íƒ
        #    - ë³´í†µ ì´ë¯¸ì§€ ì•„ë˜ìª½ 3/4 ì§€ì ì—ì„œ ë°©í–¥ê³¼ ì˜¤í”„ì…‹ì„ ë³´ê²Œ í•¨
        if self.filtered_img is not None:
            h, w = self.filtered_img.shape[:2]
        else:
            # fallback (warp ì´ë¯¸ì§€ í¬ê¸° ê¸°ì¤€)
            h, w = 160, 640

        y_eval = h * 0.75  # ì´ë¯¸ì§€ ë†’ì´ì˜ 3/4 ì§€ì 

        # 3) í•´ë‹¹ yì—ì„œ ì¤‘ì•™ì„ ì˜ x ì¢Œí‘œ ê³„ì‚°
        a, b = cfit
        x_center = a * (y_eval) + b 

        # 4) ì¤‘ì•™ì„ ì˜ ê¸°ìš¸ê¸°(dx/dy) ê³„ì‚° í›„, yaw ê°ë„(ë¼ë””ì•ˆ) ê³„ì‚°
        #    x = a*y^2 + b*y + c  â†’ dx/dy = 2*a*y + b
        dx_dy = a
        yaw = np.arctan(dx_dy)  # ì „ë°©(y ë°©í–¥) ê¸°ì¤€ xì˜ ë³€í™”ëŸ‰ì— ëŒ€í•œ ê°ë„

        # 5) ì°¨ëŸ‰ì„ ì´ë¯¸ì§€ ê°€ë¡œ ì¤‘ì•™ì— ìˆë‹¤ê³  ê°€ì •í•˜ê³ , ì¤‘ì•™ì„ ê³¼ì˜ ì˜¤í”„ì…‹ ê³„ì‚°
        img_center_x = w / 2.0
        error =  - x_center + img_center_x  # >0: ì¤‘ì•™ì„ ì´ ì˜¤ë¥¸ìª½ì— ìˆìŒ, <0: ì™¼ìª½ì— ìˆìŒ

        return yaw, error
    def draw_lane(self, image, warp_roi, inv_mat, left_fit, right_fit,warp_img0):
            """
            image    : ì›ë³¸ BGR ì´ë¯¸ì§€
            warp_roi : ROIë§Œ ì˜ë¼ë‚¸ warp ì´ë¯¸ì§€ (self.warp_img)
            inv_mat  : self.inv_warp_mat
            left_fit, right_fit : ROI ì¢Œí‘œê³„ ê¸°ì¤€ polyfit ê²°ê³¼
            """

            # 1) ì „ì²´ warp ì´ë¯¸ì§€ (ROI ìë¥´ê¸° ì „)
            if warp_img0 is not None:
                base_warp = warp_img0
            else:
                # í˜¹ì‹œë¼ë„ warp_img0ê°€ ì—†ìœ¼ë©´, ê¸°ì¡´ì²˜ëŸ¼ ROI ì „ì²´ë¥¼ ê¸°ì¤€ìœ¼ë¡œë¼ë„ ê·¸ë¦¬ê¸°
                base_warp = warp_roi

            full_h, full_w = base_warp.shape[:2]
            roi_h, roi_w   = warp_roi.shape[:2]

            # ROIê°€ í•­ìƒ ì•„ë˜ìª½ì„ ìë¥´ê³  ìˆìœ¼ë‹ˆê¹Œ:
            #   ì˜ˆ) full_h = 480, roi_h = 170 -> offset = 480 - 170 = 310
            roi_offset_y = full_h - roi_h

            # 2) ROI ì¢Œí‘œê³„ì—ì„œ ì¤‘ì•™ì„  ê·¸ë¦´ yì¶•
            yMax = roi_h
            ploty = np.linspace(0, yMax - 1, yMax)

            # ROI ê¸°ì¤€ xì¢Œí‘œ
            left_fitx  = left_fit[0] * ploty + left_fit[1] * ploty
            right_fitx = right_fit[0] * ploty + right_fit[1] 

            # 3) ROI yì¢Œí‘œë¥¼ ì „ì²´ warp ì¢Œí‘œê³„ë¡œ ì˜¬ë ¤ ë¶™ì´ê¸°
            ploty_full = ploty + roi_offset_y  # ì—¬ê¸°ì„œê°€ í•µì‹¬!

            pts_left  = np.array([np.transpose(np.vstack([left_fitx,  ploty_full]))])
            pts_right = np.array([np.flipud(np.transpose(np.vstack([right_fitx, ploty_full])))])

            pts = np.hstack((pts_left, pts_right))

            # 4) ì „ì²´ warp í¬ê¸°ì˜ ë¹ˆ ì»¬ëŸ¬ ì´ë¯¸ì§€ ë§Œë“¤ê³  lane area ì±„ìš°ê¸°
            color_warp = np.zeros_like(base_warp).astype(np.uint8)  # full_h x full_w

            cv.fillPoly(color_warp, np.int32([pts]), (0, 255, 0))
            cv.imshow('debug',color_warp)
            # 5) ì—­ì›ê·¼ë³€í™˜ìœ¼ë¡œ ì›ë³¸ ì´ë¯¸ì§€ ì¢Œí‘œê³„ë¡œ ë˜ëŒë¦¬ê³  ì˜¤ë²„ë ˆì´
            newwarp = cv.warpPerspective(color_warp, inv_mat, (image.shape[1], image.shape[0]))
            result = cv.addWeighted(image, 1, newwarp, 0.3, 0)

            return result

    def process_frame(self, frame):
        self.bgr = frame.copy()

        warp_img0 = self.warpping(self.bgr)
        warp_img = self.roi_set(warp_img0)
        g_filtered = self.Gaussian_filter(warp_img)
        self.white_img = self.white_color_filter_hsv(g_filtered)
        self.filtered_img = self.binary_filter(self.white_img)

        lfit, rfit = self.sliding_window(self.filtered_img)

        yaw, error = self.cal_center_line(lfit, rfit)
        steering, speed = self.cal_steering(yaw=yaw, error=error)

        # ì›ë³¸ + ì°¨ë¡œ ì˜ì—­ ì˜¤ë²„ë ˆì´
        debug2_img = self.draw_lane(self.bgr, warp_img, self.inv_warp_mat, lfit, rfit,warp_img0)

        # ğŸ”¥ yaw / error ì‹œê°í™”ëœ ROI ë””ë²„ê·¸ ì´ë¯¸ì§€
        yaw_debug_img = self.draw_yaw_debug(warp_img, lfit, rfit, yaw, error)

        # ë””ë²„ê·¸ ì°½ë“¤
        cv.imshow('1 warp_img', warp_img0)
        cv.imshow('2 roi_warp', yaw_debug_img)   # ì—¬ê¸°ë§Œ êµì²´!
        cv.imshow('Binary_img', self.filtered_img)

        # overlay ê²°ê³¼ëŠ” ê·¸ëŒ€ë¡œ Result ì°½ì—ì„œ ë³´ê¸°
        return debug2_img, steering, speed, yaw, error

    

    def draw_yaw_debug(self, roi_img, lfit, rfit, yaw, error):
            """
            roi_img: self.roi_set(self.warpping(..)) í•œ ë’¤ì˜ ROI ì´ë¯¸ì§€
            lfit, rfit: ì™¼/ì˜¤ë¥¸ìª½ ì°¨ì„  polyfit ê²°ê³¼
            yaw, error: cal_center_lineì—ì„œ ê³„ì‚°í•œ ê°’
            """

            debug = roi_img.copy()
            h, w = debug.shape[:2]

            # 1) ì¤‘ì•™ì„ (ì™¼+ì˜¤ë¥¸ìª½ í‰ê· ) ê³¡ì„  ê·¸ë¦¬ê¸°
            cfit = (lfit + rfit) / 2.0
            ploty = np.linspace(0, h - 1, h)
            center_x = cfit[0] * ploty + cfit[1]

            pts_center = np.vstack([center_x, ploty]).T.astype(np.int32)
            pts_center = pts_center.reshape(-1, 1, 2)
            # ë¹¨ê°„ìƒ‰ ì¤‘ì•™ì„ 
            cv.polylines(debug, [pts_center], False, (0, 0, 255), 2)

            # 2) ì°¨ì˜ ì§„í–‰ ë°©í–¥ ê¸°ì¤€ ìˆ˜ì§ì„  (ì´ë¯¸ì§€ ì •ì¤‘ì•™ x)
            img_center_x = int(w / 2)
            # íŒŒë€ìƒ‰ ìˆ˜ì§ì„ 
            cv.line(debug,
                    (img_center_x, h),   # ì•„ë˜ìª½
                    (img_center_x, 0),   # ìœ„ìª½
                    (255, 0, 0), 2)

            # 3) yaw, error í‘œì‹œìš© ê¸°ì¤€ ì§€ì  (y_eval)
            y_eval = int(h * 0.75)
            x_center_eval = int(
                cfit[0] * (y_eval) + cfit[1]  
            )

            # ë…¸ë€ ê°€ë¡œì„ : ì¤‘ì•™ì„  vs ì´ë¯¸ì§€ ì¤‘ì•™ ì‚¬ì´ì˜ ì˜¤ì°¨
            cv.line(debug,
                    (img_center_x, y_eval),
                    (x_center_eval, y_eval),
                    (0, 255, 255), 2)

            # ë‘ ì  ë§ˆì»¤
            cv.circle(debug, (img_center_x, y_eval), 4, (255, 255, 255), -1)  # ì°¨ ì¤‘ì‹¬
            cv.circle(debug, (x_center_eval, y_eval), 4, (0, 255, 0), -1)     # ì¤‘ì•™ì„ 

            # 4) í…ìŠ¤íŠ¸ë¡œ yaw / error í‘œì‹œ
            steer_deg = np.rad2deg(yaw)
            text1 = f"yaw: {yaw:.3f} rad ({steer_deg:.1f} deg)"
            text2 = f"err: {error:.1f} px"

            cv.putText(debug, text1, (10, 25),
                    cv.FONT_HERSHEY_SIMPLEX, 0.7, (0, 255, 255), 2, cv.LINE_AA)
            cv.putText(debug, text2, (10, 55),
                    cv.FONT_HERSHEY_SIMPLEX, 0.7, (0, 255, 255), 2, cv.LINE_AA)

            return debug



def main():
    # ë¹„ë””ì˜¤ íŒŒì¼ ê²½ë¡œ
    video_path = '/songdo/output_steer.mp4'

    cap = cv.VideoCapture(video_path)
    if not cap.isOpened():
        print(f'ë¹„ë””ì˜¤ íŒŒì¼ì„ ì—´ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: {video_path}')
        return

    lane_follower = LaneFollowVideo()

    paused = False  # ì¼ì‹œì •ì§€ ìƒíƒœ í”Œë˜ê·¸
    print("Controls:  [SPACE] ì¼ì‹œì •ì§€/ì¬ìƒ  |  [f] 5ì´ˆ ìŠ¤í‚µ  |  [q] ì¢…ë£Œ")

    while True:
        # ì¼ì‹œì •ì§€ ìƒíƒœê°€ ì•„ë‹ ë•Œë§Œ ìƒˆ í”„ë ˆì„ ì½ê¸°
        if not paused:
            ret, frame = cap.read()
            if not ret:
                print('ë¹„ë””ì˜¤ ë!')
                break

            result_img, steering, speed, yaw, error = lane_follower.process_frame(frame)

            # ê°’ í™•ì¸ìš© ì¶œë ¥
            print(f'yaw: {yaw:.3f}, error: {error:.1f}, steer: {steering:.3f}, speed: {speed:.2f}')

            cv.imshow('Result (overlay)', result_img)

        # pausedì¼ ë•ŒëŠ” ë§ˆì§€ë§‰ í”„ë ˆì„ í™”ë©´ ê·¸ëŒ€ë¡œ ë‘ê³  í‚¤ ì…ë ¥ë§Œ ê¸°ë‹¤ë¦¼
        delay = 0 if paused else 30  # ì¼ì‹œì •ì§€ ì¤‘ì—ëŠ” í‚¤ ì…ë ¥ ìˆì„ ë•Œê¹Œì§€ ëŒ€ê¸°
        key = cv.waitKey(delay) & 0xFF

        if key == ord('q'):
            # q: ì¢…ë£Œ
            break

        elif key == ord(' '):
            # SPACE: ì¼ì‹œì •ì§€ / ì¬ìƒ í† ê¸€
            paused = not paused
            if paused:
                print("â¸ ì¼ì‹œì •ì§€ (SPACE ë‹¤ì‹œ ëˆ„ë¥´ë©´ ì¬ìƒ)")
            else:
                print("â–¶ ì¬ìƒ")

        elif key == ord('f'):
            # f: 5ì´ˆ ì•ìœ¼ë¡œ ìŠ¤í‚µ (fast-forward)
            fps = cap.get(cv.CAP_PROP_FPS)
            if fps <= 0:
                print("âš  FPS ì •ë³´ë¥¼ ê°€ì ¸ì˜¬ ìˆ˜ ì—†ì–´ ìŠ¤í‚µ ë¶ˆê°€")
                continue

            frames_to_skip = int(5 * fps)  # 5ì´ˆì¹˜ í”„ë ˆì„ ìˆ˜
            current_frame = int(cap.get(cv.CAP_PROP_POS_FRAMES))
            target_frame = current_frame + frames_to_skip

            cap.set(cv.CAP_PROP_POS_FRAMES, target_frame)
            paused = False  # ìŠ¤í‚µ í›„ì—ëŠ” ìë™ ì¬ìƒë˜ë„ë¡
            print(f"â© 5ì´ˆ ìŠ¤í‚µ (ëŒ€ëµ {target_frame}ë²ˆì§¸ í”„ë ˆì„ìœ¼ë¡œ ì´ë™)")

    cap.release()
    cv.destroyAllWindows()

    cap.release()
    cv.destroyAllWindows()

    cap.release()
    cv.destroyAllWindows()


if __name__ == '__main__':
    main()
